// A simple loom heddle

// Number of warp threads
warp_count = 95;

// Width of each thread (mm)
warp_diameter = 2;

// Total high of the heddle (mm)
heddle_height = 200;

// Edge-to-edge width of the heddle (mm)
heddle_width = 640;

// Thickness of the frame (horizontal) (mm)
heddle_frame_width_h = 20;

// Thickness of the frame (vertical) (mm)
heddle_frame_width_v = 20;

// 3D thickness (mm)
thickness_3d = 2;

//2D to make DXF files, 3D for STL
2Dv3D = "2D"; // [2D, 3D]

/* [Hidden] */
$fn = 60;
corner_radius = 4;
hole_size = warp_diameter * 2;
hang_hole_r = 2;

heddle_interior = [heddle_width - heddle_frame_width_h * 2,
                   heddle_height - heddle_frame_width_v * 2,
                   thickness_3d];
heddle_interior_offset = [heddle_frame_width_h, heddle_frame_width_v, 0];

tt = 0.1;

if (2Dv3D == "2D") {
  projection() heddle();
} else {
  heddle();
}

/**
 * A cube with rounded corners (in the x and y axes) of radius r.
 */
module cube_rounded_xy(size, r=1) {
  translate([r, r, 0]) {
    minkowski() {
      cube(size - [r*2, r*2, 0]);
      cylinder(r=r, h=0.00001);
    }
  }
}

module heddle() {
  // main heddle body
  difference() {
    cube_rounded_xy([heddle_width,
                     heddle_height,
                     thickness_3d],
                   corner_radius);

    for (i = [0 : warp_count - 1]) {
      x = i * (heddle_interior[0] - warp_diameter)/(warp_count-1);
      translate(heddle_interior_offset + [x, 0, -tt])
        if (i % 2 == 0) {
          cube_rounded_xy([warp_diameter,
                           heddle_interior[1],
                           thickness_3d + tt * 2],
                          warp_diameter/2.1);
        } else {
          translate([0, heddle_interior[1]/2 - hole_size/2, 0])
            cube_rounded_xy([warp_diameter,
                             hole_size,
                             thickness_3d + tt * 2],
                            warp_diameter/2.1);
        }
    }
    mounting_holes();
    translate([heddle_interior[0] + heddle_interior_offset[0], 0, 0])
      mounting_holes();
  }
}

module mounting_holes() {
    hole_spacing = heddle_interior[1] - hang_hole_r * 2;
    for (n = [0 : 1])
    translate([heddle_interior_offset[0]/2, heddle_interior_offset[1] + hole_spacing/4 + (hole_spacing/2) * n + hang_hole_r, -tt])
      cylinder(r=2, h=thickness_3d+tt*2);
}
